Spring Security 

Spring Security is a powerful and highly customizable authentication and access-control framework. 

It is supplied as a "ready made aspect" , from spring security framework , that can be easily plugged in spring MVC application or RESTful web service.

It is "THE" standard for securing Spring-based applications. Spring Security is a framework that focuses on providing both authentication and authorization to Java applications. 

Like all Spring projects, the real power of Spring Security is found in how easily it can be extended to meet custom requirements.

Features

1. Comprehensive and extensible support for both Authentication and Authorization
2. Protection against attacks like session fixation, clickjacking, cross site request forgery(CSRF), etc..
3.Servlet API integration (Uses Servlet Filter chain)
4.Integration with Spring Web MVC.




Spring Security Architecture

Dev Steps 
1. Add spring security starter dependency in pom.xml
Effect -> all end points - protected (secured) - in accessible
 - Entire spring boot app 
  - under the authentication lock.

2. Defaults offered by  spring security -
- protects all endpoints (including swagger)
- supplies auto generated login n logout pages
  -  to support form login based authentication
  - suitable in MVC web applications

- supports HTTP Basic authentication for REST clients
- suplies default user
 - name : user
 - password - randomly generated by spring security
-  Offers CSRF(Cross Site Request Forgery)  protection
 - Creates HttpSession object , to store spring security context (info)

2.1 Why CSRF protection is NOT required in REST APIs ?
 - CSRF attacker basically uses cookies to forge your requests, to the vulnearable web site.
 - Since in RESTful web service , we will NOT use HttpSession or jsessionid cookie (since its stateless architecture)  , you can disable the CSRF protection.

It's definitely required in monolithic web app using HttpSession.

2.2 Customize spring security , by adding security config class
 - disable CSRF protection (csrf.disable())
 - session creation policy - stateless (sessionManagement  - sessionCreationPolicy(SessionCreationPolicy.STATELESS))
 - disable form login based authentication (it is disabled by defualt, if not added )
 - enable basic authentication scheme , for REST clients (httpBasic - (Customizer.withDefaults());
 - replace spring security generated user name (user) n password by custom user name n password.
  - using application.properties file.

2.2 Identify Security requirements for your backend application (Role based Authorization) 
Public end points (no authentication required)
These are typically open to everyone — before login or signup.

/patients/register , method=POST - Patient registration
/doctors/register , method= POST - Doctor registration
/users/signin	, method=POST - Common Login - returns AuthResp 
/swagger-ui/**	—	Swagger / API docs
/v3/api-docs/**	—	OpenAPI JSON for Swagger

These endpoints must be permitAll().


Once logged in (Authenticated), these endpoints require proper roles.
 Doctor Endpoints (ROLE_DOCTOR only)

/doctors/{id}/appointments	GET	List doctor’s upcoming appointments
/doctors/{id}/appointments/{appointmentId}/cancel	PATCH	Cancel an appointment
/doctors/{id}/prescriptions	POST	Prescribe diagnostic tests
/doctors/{id}/appointments/between	GET	Appointments in date range

→ hasRole("DOCTOR")

 Patient Endpoints (ROLE_PATIENT only)

/patients/{id}	GET	View profile details
/patients/{id}/appointments	GET	List upcoming appointments
/patients/{id}/appointments	POST	Book appointment
/patients/{id}/appointments/{appointmentId}/cancel	PATCH|DELETE	Cancel appointment
/patients/{id}/diagnostics	GET	List diagnostic tests
→ hasRole("PATIENT")


Admin Endpoints (ROLE_ADMIN only)

/admin/doctors	GET	List all doctors
/admin/patients	GET	List all patients
/admin/appointments	GET	List all appointments


3. Add spring sec user name n password in app properties file , to replace auto generated details.
    -user details are stored in mem.

4. Test end points using 
 - browser - swagger (Authorize Button)
 - postman - basic auth.

4.2 Add Spring security configuration 
 - to disable CSRF protection
(Since CSRF protection is required in - stateful web app n not in stateless REST APIs - where entire state management is done on client side)


5. Authentication was done BUT no authorization!
6. To override defaults -
  - create spring configuration class
  - Annotations 
   - @Configuration
   - @EnableWebSecurity
   - @EnableMethodSecurity
7. Add a Bean (@Bean annotated method) 
 - to supply user details
  - using ready made imple class of UserDetailsService i/f
   - InMemoryUserDetailsManger - class 
    - added user details (name , pwd, Collection<GrantedAuthority> roles)
    - UserDetails - i/f - implemented by User class - spring sec class

8. Add a Bean (@Bean annotated method) 
 - to supply authorization rules, disable form login , disable CSRF ,enable basic auth , disable session ,
 - To return : SecurityFilterChain
 - Depcy (method arg) - HttpSecurity
 - disable CSRF protection (since RESTful web service - stateless)
 - authorized HTTP reqs 
  - permit all
   - swagger ("/v*/api-docs/**","/swagger-ui/**")
   - user siginin , user signup
   - public end points (eg - view products , check available flights...)
  - only authentication (eg - add product to cart)
  - authentication + authorization (eg - add product)
  - disable form login
  - enable basic auth (to be replaced later by JWT - more secure)
  - HTTP session  management - disable HTTP session


Flow 
REST clnt sends a request to REST server 
-> Intercepted by DelegatingFilterProxy
 - It is a Filter class .
 - Acts as bridge between servlet filters n spring beans
 - Delegates all work to a Spring-managed filter bean : FilterChainProxy
  -> Delegates To springSecurityFilterChain.
-> Spring sec filter chain  takes over 
 -> current filter - BasicAuthenticationFilter
  - Base 64  decoding of username:password
(Basic base64 enc username:password) - req header - "Authorization"
 -> BasicAuthenticationFilter delegates the authentication to AuthenticationManager (i/f) <--- imple by ProviderManager
 -> i.e Filter invokes - public Authentication authenticate(Authentication auth) throws AuthenticationException
 -> Authentication i/f 
  - auth token
  - imple class
  - UserNamePasswordAuthenticationToken
  - Filter creates instance of the UserNamePasswordAuthenticationToken(Object username ,Object password)
  - isAuthenticated : false (=> authentication is not yet done!)

-> AuthMgr iterates through the list of available AuthProviders
 - AuthMgr invokes supports() method
  - rets false - continues 
  - rets true 
   - AuthMgr calls - authenticate(Authentication obj) method of  selected Auth Provider

-> AuthenticationProvider -i/f 
 - imple by DaoAuthenticationProvider (default provider)

->2 Dependencies of AuthenticationProvider
   -1.  PasswordEncoder (i/f) <--- BCryptPasswordEncoder (imple class)
    - supplied by spring sec crypto package
    - to make it available as the dependency
     - configure it as a spring bean (@Bean)
     - in spring application class (main)
    - internally used by DaoAuthenticationProvider 
     - to encrypt (SHA-256 | 512) incoming password
    - 2. UserDetailsService i/f 
     - DaoAuthProvider uses it to fetch user details from either In mem | DB
     - Functional i/f
     - SAM - functional method
      -public UserDetails loadUserByUserName(String userName|email) throws            	UserNameNotFoundException
     
     - UserDetails - i/f 
      - represents actual user details fetched  from DB or memory
      - Methods
        public String getUserName()
	public String getPassword()
        public Collection<? extends GrantedAuthority> getAuthorities()

     -> DaoAuthProvider calls 
       loadUserByUserName(username) of UserDetailsService
       -> in case of success (=> username found)
           - rets UserDetails loaded from mem | db 
           - DaoAuthProvider verifies - pwd
            - tries to match incoming encrypted password  with the pwd stored in 			UserDetails object
            - in case of a match - authentication successfully done ! 
   -> DaoAuthProvider rets verified UserDetails to -> Auth Mgr
     -> It stores verified UserDetails in the Authentication object
        - sets isAuthenticated - true
    -> AuthMgr rets this fully authenticated , 
          Authentication object to BasicAuthFilter 
      - Authentication has - username , pwd : null ,Collection<GrantedAuthority> 

    -> BasicAuthFilter stores Authentication obj under Spring security Context

   -> Next important  filter AuthorizationFilter
     -> Extracts Granted Authorities from Spring security Context
           n performs role based authorization. 

    ->in case of complete success ->delegates the request to D.S (Front controller)
 
   -> In case of Authentication failure (AuthenticationException)
 -> Spring sec aborts the req processing -> sends SC 401 to the clnt
   ->  In case of Authorization failure (AuthorizationException)
 -> aborts the req processing -> sends SC 403 to the clnt


 
Next Dev steps (project - healthcare_backend_secured_2)
 Replace In mem user details service  by DB based auth.
 BUT will still use BasicAuth

1. Remove UserDetailsService bean form spring config file
2. Create custom imple class for - UserDetailsService
3. imple the method - loadUserByUserName
4. UserEntity implements - UserDetails
5. UserDao 
 - finder method - findByEmail
6. Test it !
 - test user signup (with encode pwd)
 - user sign in 
  - use postman client (Basic auth - username:pwd) or swagger

Eg. patient
{
  "email": "ankit.pat@medcare.com",
  "password": "abc#1234"
}

Instead of using postman 
 - configure Authorization header from Swagger
- Create separate Swagger configuration class 
- Add swagger annotations

@SecurityScheme(
        name = "basicAuth",
        type = SecuritySchemeType.HTTP,
        scheme = "basic"
)

// JWT BEARER TOKEN AUTH
//@SecurityScheme(
//        name = "bearerAuth",
//        type = SecuritySchemeType.HTTP,
//        scheme = "bearer",
//        bearerFormat = "JWT"
//)

@OpenAPIDefinition(info = @Info(title = "Health Care API", version = "v1.0"), security = {
		
		@SecurityRequirement(name = "basicAuth") })
@Configuration
public class SwaggerConfig {
}

Test it !


Next Objective - Replace Basic Auth mechanism by JWT (project )
(Json Web Token)
Refer - jwt.io

Dev steps 
1. Copy from earlier basic auth sec project
1.1 Remove Basic Auth support
 - from spring sec config class.

1.2 Add JWT dependencies , 
 To create n later validate token.
 - jjwt api
 - jjwt impl
 - jjwt jackson

2. Modify  end point in UserController
 user sign in
  URL - http://host:port/users/signin
  Method - POST
  Payload - DTO (email n pwd)
  - success  - SC 201 - Auth Resp - message  +signed JWT
  - failed - SC 401 => authentication failed 

2.1 In user sign in 
 - Simply call AuthenticationManager's authenticate method
  - Configure AuthenticationManager as a spring bean 
   - in spring sec config class
 - authenticate
    i/p - Authentication <- UserNamePasswordAuthToken (em,pass)
    o/p - throws exc | fully populated Auth object (em,pwd - null, granted authorities)
   -> simply add it to JWT 
    
   -> generate token.
   -> generate Auth Resp (userId , email,message)		 
   -> sends Auth resp  to the clnt 
   Handle Spring Security AuthenticationExcpetion & AccessDeniedException in Global Exc Handler.

3. JWT token generation steps
3.1 Add JJWT dependencies in pom.xml
 -
3.2 Add 2 custom properties in application.properties file
      - JWT expiration time (in msec)
      - secret key (256 bit min - SHA256)

To create JWT secret keys , Refer - https://jwtsecrets.com/ 

3.3 Create 
 - JWT Utils for the token generation
  - create token (to be used in sign in) 
Steps 
  1. Create a secret symmetric key(Using HMAC-SHA) algorithm in init method
   Keys.hmacShaKeyFor(byte[] bytes);	
  2. To generate token
   - Use Jwts - a factory class - builder()
    - set subject : email
    - set issued at date
    - set expiry date
    - set custom Claims (userId & role) , using claims(Map)
    -sign it with secret key
    - build the token. (compact())

  - validate token (to be used custom JWT filter) - Later
   Steps 
   1. Create Jwts parser builder (Jwts.parser())
   2. Verify it with same secret key (verifyWith(key))
   3. Build parser (build)
   4. Parse signed claims (parseSignedClaims(jwt))
   5. Get claims (getPayload()) & return it to the custom filter.

3.4 Test User sign in endpoint (in swagger)
 - in case of successful auth 
 - JWT should be seen in response.


4. In JS client (eg React Client)
 - store this token in local | session storage.
 - Any time clnt is making a request to the secured end point ,
  send this token (using React Interceptor) , in Authorization header 
-> to the server.

5. Since there is no readymade filter for JWT  verification
Create custom JWT filter 
 -  to intercept every incoming request (extending from OncePerRequestFilter)
 - Check if  token exists , if yes extract it from Authorization Header.
 - Validate Token from JwtUtils & get the Claims in the token.
 - in case of success(i.e no exception) , wrap claims & email in the Token DTO (jwt user)
    - API claims.get(String name , Class class)
 	- userId,role , getSubject()- email	
    Create Authentication object 
     - UsernamePasswordAuthenticationToken with
      - Principal - jwt user
      - credentials (password) - null,
      - Collection of GrantedAuthority		
					 
   - store this  authentication object under Spring Security Context (SecurityContextHolder)

6. Add custom jwt filter before 
 UserNamePasswordAuthenticationFilter
 - in spring sec config class.

7. Test it !
 - postman 
(Use Auth - Bearer Token 
 paste - JWT token )
 Test secured end points for
  - authentication
  - role based authorization.

Extra Optional Steps 


8. Problem Observed 
- In case client wants to access protected end point , but doesn't send any JWT 
- what should be error code ?
 - SC 401 | SC 403

9. To solve this error 
- Add a class
 -  implements AuthenticationEntryPoint 
 - configure it as spring bean.
  - implement method 
   - public void commence(HttpServletRequest request,
                         HttpServletResponse response,
                         AuthenticationException authException) throws IOException {
     - send error response.
         
10. To Handle unauthenticated access with 401
- add in spring sec config class  , security filter chain 
 - http.exceptionHandling(ex -> ex.authenticationEntryPoint(jwtAuthEntryPoint));

